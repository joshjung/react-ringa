{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-ringa.min.js","webpack:///webpack/bootstrap 4d27d68c1b3b1614c8b0","webpack:///./src/util.js","webpack:///./src/queueState.js","webpack:///./src/attach.js","webpack:///./src/depend.js","webpack:///./src/watch.js","webpack:///./src/index.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\",\"umd\":\"react\"}","webpack:///external {\"root\":\"ReactDOM\",\"commonjs2\":\"react-dom\",\"commonjs\":\"react-dom\",\"amd\":\"react-dom\",\"umd\":\"react-dom\"}","webpack:///external {\"root\":\"Ringa\",\"commonjs2\":\"ringa\",\"commonjs\":\"ringa\",\"amd\":\"ringa\",\"umd\":\"ringa\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_6__","__WEBPACK_EXTERNAL_MODULE_7__","__WEBPACK_EXTERNAL_MODULE_8__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","domNodeToNearestReactComponent","domNode","key","startsWith","_react2","version","curFiber","stateNode","Component","return","_currentElement","_owner","_instance","parentNode","domNodeToNearestReactComponentDomNode","walkReactParents","component","callback","_reactInternalFiber","_walkReactParents16","_walkReactParents15","ancestors","fiber","item","indexOf","push","$ringaAlternateParentComponent","forEach","_reactInternalInstance","_hostParent","getAllReactComponentAncestors","getAllListeningControllers","controllers","parents","$ringaControllers","length","concat","findComponentRoot","refName","refs","_reactDom2","findDOMNode","console","warn","constructor","_reactDom","_react","unqueueState","reactComponent","__ringaStateQueueTimeout","clearTimeout","__ringaStateQueue","queueState","newState","inComponentWillMount","arguments","undefined","state","updater","isMounted","assign","setTimeout","setState","ns","attach","controllerOrModel","_ref","_ref$refName","_ref$callback","_ref$bus","bus","_componentDidMount","_componentWillUnmount","controller","_ringa","Controller","addModel","componentDidMount","bind","componentWillUnmount","postMountFunction","doNotCallMount","_util","mounted","ix","splice","dependency","classOrId","propertyPaths","setOnState","setOnComponent","setStateAs","_ref$setOnState","_ref$setStateAs","_ref$setOnComponent","find","propertyPath","mw","modelWatcher","depend","watches","handler","_componentWillMount","componentWillMount","mws","_queueState","mwGroup","unwatch","changeHandler","error","Array","watch","foundModels","model","pp","changes","change","propertyObj","watchedValue","watchedPath","endsWith","initial","watchedModel","properties","prop","signalPath","split","pop","signalValue","propertyPathObj","_typeof","Symbol","iterator","signals","Error","$watches","curHandler","id","signal","descriptor","path","fu","found","_signal","subSignal","apply","_attach","_attach2","_watch","_watch2","_depend"],"mappings":"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","file":"react-ringa.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"), require(\"react-dom\"), require(\"ringa\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\", \"react-dom\", \"ringa\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"React Ringa\"] = factory(require(\"react\"), require(\"react-dom\"), require(\"ringa\"));\n\telse\n\t\troot[\"React Ringa\"] = factory(root[\"React\"], root[\"ReactDOM\"], root[\"Ringa\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"), require(\"react-dom\"), require(\"ringa\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\", \"react-dom\", \"ringa\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"React Ringa\"] = factory(require(\"react\"), require(\"react-dom\"), require(\"ringa\"));\n\telse\n\t\troot[\"React Ringa\"] = factory(root[\"React\"], root[\"ReactDOM\"], root[\"Ringa\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.domNodeToNearestReactComponent = domNodeToNearestReactComponent;\nexports.domNodeToNearestReactComponentDomNode = domNodeToNearestReactComponentDomNode;\nexports.walkReactParents = walkReactParents;\nexports.getAllReactComponentAncestors = getAllReactComponentAncestors;\nexports.getAllListeningControllers = getAllListeningControllers;\nexports.findComponentRoot = findComponentRoot;\n\nvar _reactDom = __webpack_require__(7);\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _react = __webpack_require__(6);\n\nvar _react2 = _interopRequireDefault(_react);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Walks the dom ancestors until it finds the nearest dom node that has a ref to a React Component and then\n * returns that React Component.\n *\n * @param domNode The DOM node to start with.\n * @returns {*}\n */\nfunction domNodeToNearestReactComponent(domNode) {\n  while (domNode) {\n    for (var key in domNode) {\n      if (key.startsWith('__reactInternalInstance$')) {\n        // Please don't judge me when you read this code.\n\n        if (_react2.default.version.startsWith('16')) {\n          // In React Fiber, every node in the tree (including dom nodes) is represented in the Fiber tree. So we\n          // have to search through all the parents to find the first one that has a stateNode that is a React Component\n          var curFiber = domNode[key];\n\n          while (curFiber && !(curFiber.stateNode instanceof _react2.default.Component)) {\n            curFiber = curFiber.return;\n          }\n\n          return curFiber.stateNode;\n        }\n\n        // React 15\n        return domNode[key]._currentElement._owner._instance;\n      }\n    }\n\n    domNode = domNode.parentNode;\n  }\n\n  return null;\n}\n\n/**\n * Walks the dom ancestors until it finds the nearest dom node that has a ref to a React Component and then returns\n * that dom node.\n *\n * @param domNode The DOM node to start with.\n * @returns {*}\n */\nfunction domNodeToNearestReactComponentDomNode(domNode) {\n  while (domNode) {\n    for (var key in domNode) {\n      if (key.startsWith('__reactInternalInstance$')) {\n        return domNode;\n      }\n    }\n\n    domNode = domNode.parentNode;\n  }\n\n  return null;\n}\n\n/**\n * Walks the React Components up through the parent heirarchy.\n *\n * @param component A React Component instance.\n * @param callback A callback to call for each component in the ancestors.\n */\nfunction walkReactParents(component, callback) {\n  if (component._reactInternalFiber) {\n    return _walkReactParents16(component, callback);\n  } else {\n    return _walkReactParents15(component, callback);\n  }\n}\n\nfunction _walkReactParents16(component, callback) {\n  var ancestors = [];\n\n  var fiber = component._reactInternalFiber;\n\n  while (fiber) {\n    var item = fiber.stateNode;\n\n    if (item && item instanceof _react2.default.Component) {\n      if (ancestors.indexOf(item) === -1) {\n        ancestors.push(item);\n      }\n    }\n\n    if (item && item.$ringaAlternateParentComponent) {\n      item = item.$ringaAlternateParentComponent;\n      ancestors.push(item);\n      fiber = item._reactInternalFiber;\n    } else {\n      fiber = fiber.return; // return is the parent node, go figure (ask Facebook)\n    }\n  }\n\n  if (callback) {\n    ancestors.forEach(callback);\n  }\n\n  return ancestors;\n}\n\nfunction _walkReactParents15(component, callback) {\n  var ancestors = [];\n\n  component = component._reactInternalInstance;\n\n  while (component) {\n    var item = component._instance || component._currentElement._owner._instance;\n\n    if (ancestors.indexOf(item) === -1) {\n      ancestors.push(item);\n    }\n\n    if (item.$ringaAlternateParentComponent) {\n      component = item.$ringaAlternateParentComponent._reactInternalInstance;\n    } else {\n      component = component._hostParent;\n    }\n  }\n\n  if (callback) {\n    ancestors.forEach(callback);\n  }\n\n  return ancestors;\n}\n\n/**\n * Returns all Ringa.Controller instances that exist in the ancestor tree.\n *\n * @param component A React Component instance.\n * @returns {Array}\n */\nfunction getAllReactComponentAncestors(component) {\n  return walkReactParents(component);\n}\n\n/**\n * Returns all Ringa.Controller instances that will hear when you dispatch an event from any of the provided React component's\n * DOM nodes or its descendants.\n *\n * @param component A React Component instance.\n * @returns {Array}\n */\nfunction getAllListeningControllers(component) {\n  var controllers = [];\n  var parents = [];\n\n  walkReactParents(component, function (c) {\n    parents.push(c);\n    if (c.$ringaControllers && c.$ringaControllers.length) {\n      controllers = controllers.concat(c.$ringaControllers);\n    }\n  });\n\n  return controllers;\n}\n\nfunction findComponentRoot(component, refName) {\n  var domNode = void 0;\n\n  // First look for a ref to attach to...\n  if (!component.refs || !component.refs[refName]) {\n    // Second use react-dom to find the root node for the component...\n\n    domNode = _reactDom2.default.findDOMNode(component);\n\n    if (!domNode) {\n      console.warn('attach(): Error finding root DOM node for React Component ' + component.constructor.name + '. Component ref named \\'' + refName + '\\' does not exist and ReactDOM findDomNode(component) did not return anything. This can happen if the render() method returns null or undefined.');\n    }\n\n    return domNode;\n  } else {\n    domNode = component.refs[refName];\n  }\n\n  return domNode;\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unqueueState = unqueueState;\nexports.queueState = queueState;\nfunction unqueueState(reactComponent) {\n  if (reactComponent.__ringaStateQueueTimeout) {\n    clearTimeout(reactComponent.__ringaStateQueueTimeout);\n    delete reactComponent.__ringaStateQueueTimeout;\n  }\n\n  delete reactComponent.__ringaStateQueue;\n}\n\nfunction queueState(reactComponent, newState) {\n  var inComponentWillMount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (!reactComponent.state) {\n    reactComponent.state = newState;\n    return;\n  }\n\n  if (!reactComponent.updater.isMounted(reactComponent)) {\n    if (inComponentWillMount) {\n      for (var key in newState) {\n        reactComponent.state[key] = newState[key];\n      }\n    } else {\n      var ns = Object.assign(newState, reactComponent.state);\n      reactComponent.state = ns;\n    }\n\n    return;\n  }\n\n  reactComponent.__ringaStateQueue = reactComponent.__ringaStateQueue || {};\n  reactComponent.__ringaStateQueue = Object.assign(reactComponent.__ringaStateQueue, newState);\n\n  if (reactComponent.__ringaStateQueueTimeout) {\n    return;\n  }\n\n  reactComponent.__ringaStateQueueTimeout = setTimeout(function () {\n    var before = void 0;\n    if (false) {\n      before = new Date().getTime();\n    }\n    reactComponent.__ringaStateQueueTimeout = 0;\n    reactComponent.setState(reactComponent.__ringaStateQueue);\n    if (false) {\n      if (new Date().getTime() - before > 100) {\n        console.warn('react-ringa __DEV__: component update took longer than 100 milliseconds, consider improving the following component:', reactComponent, 'newState being assigned was: ', newState);\n      }\n      try {\n        reactComponent.$ringaTriggerProperties = Object.keys(reactComponent.__ringaStateQueue);\n      } catch (error) {/* TODO this was crashing... sometimes. don't really care about an error for a debugging feature too much. */}\n    }\n    delete reactComponent.__ringaStateQueue;\n  }, 0);\n}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = attach;\n\nvar _util = __webpack_require__(0);\n\nvar _ringa = __webpack_require__(8);\n\n/**\n * This function attaches a Ringa Controller or Model to a specific React.Component and a selected DOM node within that component.\n *\n * Note that a Ringa controller is attached to a React Component when componentDidMount is called on the component.\n *\n * If you provide a Ringa Model, then a dummy Controller is built and the Model is added to that controller before the Controller is\n * attached to the view.\n *\n * @param component The React Component to attach to.\n * @param controller The Ringa Controller to attach when a DOM node is available.\n * @param refName The React component reference name.\n * @param callback The function to call whenever the controller has been attached.\n */\nfunction attach(component, controllerOrModel) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$refName = _ref.refName,\n      refName = _ref$refName === undefined ? 'ringaRoot' : _ref$refName,\n      _ref$callback = _ref.callback,\n      callback = _ref$callback === undefined ? undefined : _ref$callback,\n      _ref$bus = _ref.bus,\n      bus = _ref$bus === undefined ? undefined : _ref$bus;\n\n  var _componentDidMount = void 0,\n      _componentWillUnmount = void 0;\n\n  var controller = void 0;\n\n  if (controllerOrModel instanceof _ringa.Model) {\n    controller = new _ringa.Controller();\n    controller.addModel(controllerOrModel);\n  } else {\n    controller = controllerOrModel;\n  }\n\n  if (component.componentDidMount) {\n    _componentDidMount = component.componentDidMount.bind(component);\n  }\n\n  if (component.componentWillUnmount) {\n    _componentWillUnmount = component.componentWillUnmount.bind(component);\n  }\n\n  component.$ringaControllers = component.$ringaControllers || [];\n  component.$ringaControllers.push(controller);\n\n  var postMountFunction = function postMountFunction() {\n    var doNotCallMount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var domNode = (0, _util.findComponentRoot)(component, refName);\n\n    if (bus) {\n      controller.bus = bus;\n    } else if (domNode) {\n      domNode.$ringaControllers = domNode.$ringaControllers || [];\n      domNode.$ringaControllers.push(controller);\n\n      controller.bus = domNode;\n    } else {\n      console.warn('attach(): could not find domNode to set as bus for controller ' + controller);\n    }\n\n    if (_componentDidMount && !doNotCallMount) {\n      _componentDidMount();\n    }\n\n    if (callback) {\n      callback();\n    }\n  };\n\n  component.componentDidMount = postMountFunction;\n\n  if (component.mounted) {\n    postMountFunction(true);\n  }\n\n  component.componentWillUnmount = function () {\n    var domNode = (0, _util.findComponentRoot)(component, refName);\n    var ix = void 0;\n\n    if (domNode && domNode.$ringaControllers) {\n      ix = domNode.$ringaControllers.indexOf(controller);\n\n      domNode.$ringaControllers.splice(ix, 1);\n    }\n\n    ix = component.$ringaControllers.indexOf(controller);\n    component.$ringaControllers.splice(ix, 1);\n\n    if (_componentWillUnmount) {\n      _componentWillUnmount();\n    }\n  };\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.dependency = dependency;\nexports.find = find;\nexports.depend = depend;\n\nvar _queueState = __webpack_require__(1);\n\nvar _util = __webpack_require__(0);\n\n/**\n * Builds a dependency object for use with the depend function.\n *\n * @param classOrId A Class that extends Ringa.Model or a string id of a model you are looking for.\n * @param propertyPath A dot-delimited path into a property on the model. Or undefined if you want the model itself.\n * @param setOnState When true (default), the property will be set on the state of the component, forcing an update.\n *\n * @returns {{classOrId: *, propertyPath: *, setOnState: boolean}}\n */\nfunction dependency(classOrId) {\n  var propertyPaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { setOnState: true, setOnComponent: false, setStateAs: undefined },\n      _ref$setOnState = _ref.setOnState,\n      setOnState = _ref$setOnState === undefined ? true : _ref$setOnState,\n      _ref$setStateAs = _ref.setStateAs,\n      setStateAs = _ref$setStateAs === undefined ? undefined : _ref$setStateAs,\n      _ref$setOnComponent = _ref.setOnComponent,\n      setOnComponent = _ref$setOnComponent === undefined ? false : _ref$setOnComponent;\n\n  return {\n    classOrId: classOrId,\n    propertyPaths: propertyPaths,\n    setOnState: setOnState,\n    setOnComponent: setOnComponent,\n    setStateAs: setStateAs\n  };\n}\n\n/**\n * Finds a Ringa.Model or a specific property, given the context of the provided React Component.\n *\n * @param reactComponent A React Component instance.\n * @param classOrId A Class that extends Ringa.Model or a string id of a model you are looking for.\n * @param propertyPath A dot-delimited path into a property on the model. Or undefined if you want the model itself.\n * @returns {*}\n */\nfunction find(reactComponent, classOrId) {\n  var propertyPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n  var controllers = (0, _util.getAllListeningControllers)(reactComponent);\n  var value = void 0;\n\n  for (var i = 0; i < controllers.length; i++) {\n    var controller = controllers[i];\n    var mw = controller.modelWatcher;\n\n    if (mw) {\n      var _value = mw.find(classOrId, propertyPath);\n\n      if (_value) {\n        return _value;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Listens for changes on the provided React Component anywhere in its ancestor tree of Controllers for the requested Ringa.Model and,\n * if desired specific property path, changes. See getAllListeningControllers for information on the controllers and their models\n * that this will depend upon.\n *\n * Example:\n *\n * import {depend, dependency} from 'react-ringa';\n *\n * class MyComponent extends React.Component {\n *   constructor() {\n *     super();\n *\n *     depend(this, dependency('myModelId', 'some.property'));\n *   }\n * }\n *\n * @param component A React Component instance.\n * @param watches An individual or Array of dependency objects. See\n * @param handler A function to callback immediately with all the dependencies that are found right now.\n *\n * @returns {Array}\n */\nfunction depend(component, watches) {\n  var handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  var debug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  var _componentWillMount = void 0,\n      _componentWillUnmount = void 0,\n      _componentDidMount = void 0;\n\n  if (component.componentWillMount) {\n    _componentWillMount = component.componentWillMount.bind(component);\n  }\n\n  if (component.componentWillUnmount) {\n    _componentWillUnmount = component.componentWillUnmount.bind(component);\n  }\n\n  if (component.state === undefined) {\n    component.state = {};\n  }\n\n  var controllers = void 0;\n  var mws = [];\n\n  component.componentWillUnmount = function () {\n    (0, _queueState.unqueueState)(component);\n\n    /**\n     * When the component unmounts we want to unwatch everything.\n     */\n    mws.forEach(function (mwGroup) {\n      mwGroup.mw.unwatch(mwGroup.classOrId, mwGroup.propertyPath, mwGroup.changeHandler);\n    });\n\n    if (_componentWillUnmount) {\n      _componentWillUnmount();\n    }\n  };\n\n  component.componentWillMount = function () {\n    var inComponentWillMount = true;\n    controllers = (0, _util.getAllListeningControllers)(component);\n\n    if (!controllers.length) {\n      console.error('react-ringa depend(): could not find any Ringa Controllers in the ancestors of ' + component.constructor.name + ', the following dependencies will NOT work: ', watches, component);\n\n      return;\n    }\n\n    if (false) {\n      console.log('depend(' + component + ', ' + watches + ') found controllers:', controllers);\n    }\n\n    watches = watches instanceof Array ? watches : [watches];\n\n    watches.forEach(function (watch) {\n      var foundModels = [];\n\n      controllers.forEach(function (controller) {\n        var mw = controller.modelWatcher;\n\n        if (mw) {\n          var model = mw.find(watch.classOrId);\n\n          if (!model) {\n            return;\n          }\n\n          foundModels.push(model);\n\n          if (false) {\n            console.warn('depend(): found two models while looking for a dependency on the \\'' + component.constructor.name + '\\' component! Watch is:\\n', watch, '\\nFound these conflicting models during the search, all of which match:\\n', foundModels, '\\ndepend() looks for the closest model in the DOM tree ancestors it can find that matches the watch criteria. This means you might have a problem in your stack. Proceeding normally with the first model in the list above. This might NOT be the right model and could cause errors. This error will not appear in production.');\n\n            return;\n          }\n\n          // By default the model we are requesting automatically gets set on the state no matter what for\n          // easy access. However, we don't watch the entire model because that would be silliness. Each view\n          // component should request the specific signals it wants to watch.\n          var s = {};\n          s[watch.setStateAs || model.name] = model;\n          (0, _queueState.queueState)(component, s, inComponentWillMount);\n\n          var value = void 0,\n              changeHandler = void 0;\n\n          // If the user is just asking for the model (no propertyPath), we can skip all the watching jargon.\n          if (watch.propertyPaths) {\n\n            var pp = watch.propertyPaths instanceof Array ? watch.propertyPaths : [watch.propertyPaths];\n\n            // Create Change Handler. Note we do not use an arrow function here to save memory.\n            changeHandler = function (watch, changes) {\n              var skipUpdate = handler ? handler(changes) : undefined;\n\n              if (skipUpdate === undefined && watch.setOnState) {\n                var newState = {};\n\n                changes.forEach(function (change) {\n                  var state = {};\n\n                  if (change.propertyObj && change.propertyObj.setStateAs) {\n                    /**\n                     * IF dependency(MyModel, 'property', {setStateAs: 'someOtherPropertyName'})\n                     */\n                    state[change.propertyObj.setStateAs] = change.watchedValue;\n                  } else if (change.watchedPath) {\n                    /**\n                     * IF dependency(MyModel, 'property.*')\n                     */\n                    if (change.watchedPath.endsWith('*')) {\n                      /**\n                       * IF dependency(MyModel, 'property.*') AND the signal was directly from MyModel\n                       */\n                      if (change.initial) {\n                        // This only occurs on the initial depend, when no signals have yet been dispatched, so we\n                        // can prepopulate each value.\n                        change.watchedModel.properties.forEach(function (prop) {\n                          state[prop] = change.watchedModel[prop];\n                        });\n                      } else {\n                        state[change.signalPath.split('.').pop()] = change.signalValue;\n                      }\n                    } else {\n                      /**\n                       * IF dependency(MyModel, 'property')\n                       */\n                      var prop = change.watchedPath.split('.').pop();\n                      state[prop] = change.watchedValue;\n                    }\n                  } else {\n                    /**\n                     * IF dependency(MyModel)\n                     */\n                    state[change.watchedModel.name] = change.watchedValue;\n                  }\n\n                  newState = Object.assign(newState, state);\n                });\n\n                (0, _queueState.queueState)(component, newState, inComponentWillMount);\n              }\n            }.bind(undefined, watch);\n\n            pp.forEach(function (propertyPath) {\n              var propertyPathObj = void 0;\n\n              if ((typeof propertyPath === 'undefined' ? 'undefined' : _typeof(propertyPath)) === 'object') {\n                propertyPathObj = propertyPath;\n                propertyPath = propertyPathObj.propertyPath;\n              }\n\n              value = mw.find(watch.classOrId, propertyPath);\n\n              mws.push({\n                mw: mw,\n                classOrId: watch.classOrId,\n                propertyPath: propertyPath,\n                propertyPathObj: propertyPathObj,\n                changeHandler: changeHandler\n              });\n\n              mw.watch(watch.classOrId, propertyPath, changeHandler);\n\n              if (changeHandler) {\n                changeHandler([{\n                  watchedModel: model,\n                  signalValue: value,\n                  watchedPath: propertyPath,\n                  watchedValue: value,\n                  propertyPathObj: propertyPathObj,\n                  initial: true\n                }]);\n              }\n            });\n          }\n        }\n      });\n\n      if (!foundModels.length) {\n        if (!watch.classOrId) {\n          console.error('depend(): could not the model as it was not specified!');\n        } else {\n          console.error('depend(): could not find the model', watch.classOrId.name, 'in any ancestor Controllers of React component', component.constructor.name, component, 'during the componentDidMount() phase. Found these instantiated and attached controllers', controllers);\n        }\n      }\n    });\n\n    if (_componentWillMount) {\n      _componentWillMount();\n    }\n\n    inComponentWillMount = false;\n  };\n}\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = watch;\n\nvar _queueState = __webpack_require__(1);\n\nfunction watch(reactComponent, model) {\n  var signals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n\n  if (model) {\n    if (!model.watch) {\n      throw new Error('react-ringa watch(): the provided object is not a Ringa Model \\'' + model + '\\'');\n    }\n\n    var _componentWillUnmount = reactComponent.componentWillUnmount ? reactComponent.componentWillUnmount.bind(reactComponent) : undefined;\n\n    reactComponent.$watches = reactComponent.$watches || {};\n\n    var curHandler = reactComponent.$watches[model.id];\n    if (curHandler) {\n      model.unwatch(curHandler);\n    }\n\n    var handler = reactComponent.$watches[model.id] = function (signal, item, value, descriptor, path) {\n      var fu = void 0;\n      var found = false;\n      signals.forEach(function (_signal) {\n        var subSignal = _signal.split('*')[0];\n\n        if (signal.startsWith(subSignal)) {\n          found = true;\n        }\n      });\n\n      if (!found && signals.length) {\n        return;\n      }\n\n      if (callback) {\n        fu = callback.apply(undefined, [signal, item, value, descriptor, path]);\n      }\n\n      if (fu === undefined) {\n        var _o = {};\n        _o[model.name] = model;\n        (0, _queueState.queueState)(reactComponent, _o);\n      }\n    };\n\n    var unwatch = function unwatch() {\n      (0, _queueState.unqueueState)(reactComponent);\n\n      model.unwatch(handler);\n    };\n\n    reactComponent.componentWillUnmount = function () {\n      unwatch();\n\n      if (_componentWillUnmount) {\n        _componentWillUnmount();\n      }\n    };\n\n    model.watch(handler);\n\n    // Initial setup\n    var o = {};\n    o[model.name] = model;\n\n    (0, _queueState.queueState)(reactComponent, o);\n\n    return unwatch;\n  }\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.domNodeToNearestReactComponentDomNode = exports.getAllReactComponentAncestors = exports.domNodeToNearestReactComponent = exports.watch = exports.getAllListeningControllers = exports.find = exports.walkReactParents = exports.dependency = exports.depend = exports.attach = undefined;\n\nvar _attach = __webpack_require__(2);\n\nvar _attach2 = _interopRequireDefault(_attach);\n\nvar _watch = __webpack_require__(4);\n\nvar _watch2 = _interopRequireDefault(_watch);\n\nvar _depend = __webpack_require__(3);\n\nvar _util = __webpack_require__(0);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.attach = _attach2.default;\nexports.depend = _depend.depend;\nexports.dependency = _depend.dependency;\nexports.walkReactParents = _util.walkReactParents;\nexports.find = _depend.find;\nexports.getAllListeningControllers = _util.getAllListeningControllers;\nexports.watch = _watch2.default;\nexports.domNodeToNearestReactComponent = _util.domNodeToNearestReactComponent;\nexports.getAllReactComponentAncestors = _util.getAllReactComponentAncestors;\nexports.domNodeToNearestReactComponentDomNode = _util.domNodeToNearestReactComponentDomNode;\nexports.default = {\n  attach: _attach2.default,\n  depend: _depend.depend,\n  dependency: _depend.dependency,\n  walkReactParents: _util.walkReactParents,\n  find: _depend.find,\n  getAllListeningControllers: _util.getAllListeningControllers,\n  watch: _watch2.default,\n  domNodeToNearestReactComponent: _util.domNodeToNearestReactComponent,\n  getAllReactComponentAncestors: _util.getAllReactComponentAncestors,\n  domNodeToNearestReactComponentDomNode: _util.domNodeToNearestReactComponentDomNode\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// react-ringa.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4d27d68c1b3b1614c8b0","import ReactDOM from 'react-dom';\nimport React from 'react';\n\n/**\n * Walks the dom ancestors until it finds the nearest dom node that has a ref to a React Component and then\n * returns that React Component.\n *\n * @param domNode The DOM node to start with.\n * @returns {*}\n */\nexport function domNodeToNearestReactComponent(domNode) {\n  while (domNode) {\n    for (let key in domNode) {\n      if (key.startsWith('__reactInternalInstance$')) {\n        // Please don't judge me when you read this code.\n\n        if (React.version.startsWith('16')) {\n          // In React Fiber, every node in the tree (including dom nodes) is represented in the Fiber tree. So we\n          // have to search through all the parents to find the first one that has a stateNode that is a React Component\n          let curFiber = domNode[key];\n\n          while (curFiber && !(curFiber.stateNode instanceof React.Component)) {\n            curFiber = curFiber.return;\n          }\n\n          return curFiber.stateNode;\n        }\n\n        // React 15\n        return domNode[key]._currentElement._owner._instance;\n      }\n    }\n\n    domNode = domNode.parentNode;\n  }\n\n  return null;\n}\n\n/**\n * Walks the dom ancestors until it finds the nearest dom node that has a ref to a React Component and then returns\n * that dom node.\n *\n * @param domNode The DOM node to start with.\n * @returns {*}\n */\nexport function domNodeToNearestReactComponentDomNode(domNode) {\n  while (domNode) {\n    for (let key in domNode) {\n      if (key.startsWith('__reactInternalInstance$')) {\n        return domNode;\n      }\n    }\n\n    domNode = domNode.parentNode;\n  }\n\n  return null;\n}\n\n/**\n * Walks the React Components up through the parent heirarchy.\n *\n * @param component A React Component instance.\n * @param callback A callback to call for each component in the ancestors.\n */\nexport function walkReactParents(component, callback) {\n  if (component._reactInternalFiber) {\n    return _walkReactParents16(component, callback);\n  } else {\n    return _walkReactParents15(component, callback);\n  }\n}\n\nfunction _walkReactParents16(component, callback) {\n  let ancestors = [];\n\n  let fiber = component._reactInternalFiber;\n\n  while (fiber) {\n    let item = fiber.stateNode;\n\n    if (item && item instanceof React.Component) {\n      if (ancestors.indexOf(item) === -1) {\n        ancestors.push(item);\n      }\n    }\n\n    if (item && item.$ringaAlternateParentComponent) {\n      item = item.$ringaAlternateParentComponent;\n      ancestors.push(item);\n      fiber = item._reactInternalFiber;\n    } else {\n      fiber = fiber.return; // return is the parent node, go figure (ask Facebook)\n    }\n  }\n\n  if (callback) {\n    ancestors.forEach(callback);\n  }\n\n  return ancestors;\n}\n\n\nfunction _walkReactParents15(component, callback) {\n  let ancestors = [];\n\n  component = component._reactInternalInstance;\n\n  while (component) {\n    let item = component._instance || component._currentElement._owner._instance;\n\n    if (ancestors.indexOf(item) === -1) {\n      ancestors.push(item);\n    }\n\n    if (item.$ringaAlternateParentComponent) {\n      component = item.$ringaAlternateParentComponent._reactInternalInstance;\n    } else {\n      component = component._hostParent;\n    }\n  }\n\n  if (callback) {\n    ancestors.forEach(callback);\n  }\n\n  return ancestors;\n}\n\n/**\n * Returns all Ringa.Controller instances that exist in the ancestor tree.\n *\n * @param component A React Component instance.\n * @returns {Array}\n */\nexport function getAllReactComponentAncestors(component) {\n  return walkReactParents(component);\n}\n\n/**\n * Returns all Ringa.Controller instances that will hear when you dispatch an event from any of the provided React component's\n * DOM nodes or its descendants.\n *\n * @param component A React Component instance.\n * @returns {Array}\n */\nexport function getAllListeningControllers(component) {\n  let controllers = [];\n  let parents = [];\n\n  walkReactParents(component, c => {\n    parents.push(c);\n    if (c.$ringaControllers && c.$ringaControllers.length) {\n      controllers = controllers.concat(c.$ringaControllers);\n    }\n  });\n\n  return controllers;\n}\n\nexport function findComponentRoot(component, refName) {\n  let domNode;\n\n  // First look for a ref to attach to...\n  if (!component.refs || !component.refs[refName]) {\n    // Second use react-dom to find the root node for the component...\n\n    domNode = ReactDOM.findDOMNode(component);\n\n    if (!domNode) {\n      console.warn(`attach(): Error finding root DOM node for React Component ${component.constructor.name}. Component ref named '${refName}' does not exist and ReactDOM findDomNode(component) did not return anything. This can happen if the render() method returns null or undefined.`);\n    }\n\n    return domNode;\n  } else {\n    domNode = component.refs[refName];\n  }\n\n  return domNode;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/util.js","export function unqueueState(reactComponent) {\n  if (reactComponent.__ringaStateQueueTimeout) {\n    clearTimeout(reactComponent.__ringaStateQueueTimeout);\n    delete reactComponent.__ringaStateQueueTimeout;\n  }\n\n  delete reactComponent.__ringaStateQueue;\n}\n\nexport function queueState(reactComponent, newState, inComponentWillMount = false) {\n  if (!reactComponent.state) {\n    reactComponent.state = newState;\n    return;\n  }\n\n  if (!reactComponent.updater.isMounted(reactComponent)) {\n    if (inComponentWillMount) {\n      for (let key in newState) {\n        reactComponent.state[key] = newState[key];\n      }\n    } else {\n      let ns = Object.assign(newState, reactComponent.state);\n      reactComponent.state = ns;\n    }\n\n    return;\n  }\n\n  reactComponent.__ringaStateQueue = reactComponent.__ringaStateQueue || {};\n  reactComponent.__ringaStateQueue = Object.assign(reactComponent.__ringaStateQueue, newState);\n\n  if (reactComponent.__ringaStateQueueTimeout) {\n    return;\n  }\n\n  reactComponent.__ringaStateQueueTimeout = setTimeout(() => {\n    let before;\n    if (__DEV__) {\n      before = new Date().getTime();\n    }\n    reactComponent.__ringaStateQueueTimeout = 0;\n    reactComponent.setState(reactComponent.__ringaStateQueue);\n    if (__DEV__) {\n      if (new Date().getTime() - before > 100) {\n        console.warn('react-ringa __DEV__: component update took longer than 100 milliseconds, consider improving the following component:', reactComponent, 'newState being assigned was: ', newState);\n      }\n      try {\n        reactComponent.$ringaTriggerProperties = Object.keys(reactComponent.__ringaStateQueue);\n      } catch (error) { /* TODO this was crashing... sometimes. don't really care about an error for a debugging feature too much. */}\n    }\n    delete reactComponent.__ringaStateQueue;\n  }, 0);\n}\n\n\n// WEBPACK FOOTER //\n// ./src/queueState.js","import {findComponentRoot} from './util';\nimport {Controller, Model} from 'ringa';\n\n/**\n * This function attaches a Ringa Controller or Model to a specific React.Component and a selected DOM node within that component.\n *\n * Note that a Ringa controller is attached to a React Component when componentDidMount is called on the component.\n *\n * If you provide a Ringa Model, then a dummy Controller is built and the Model is added to that controller before the Controller is\n * attached to the view.\n *\n * @param component The React Component to attach to.\n * @param controller The Ringa Controller to attach when a DOM node is available.\n * @param refName The React component reference name.\n * @param callback The function to call whenever the controller has been attached.\n */\nexport default function attach(component, controllerOrModel, { refName = 'ringaRoot', callback = undefined, bus = undefined } = {}) {\n  let _componentDidMount, _componentWillUnmount;\n\n  let controller;\n\n  if (controllerOrModel instanceof Model) {\n    controller = new Controller();\n    controller.addModel(controllerOrModel);\n  } else {\n    controller = controllerOrModel;\n  }\n\n  if (component.componentDidMount) {\n    _componentDidMount = component.componentDidMount.bind(component);\n  }\n\n  if (component.componentWillUnmount) {\n    _componentWillUnmount = component.componentWillUnmount.bind(component);\n  }\n\n  component.$ringaControllers = component.$ringaControllers || [];\n  component.$ringaControllers.push(controller);\n\n  const postMountFunction = (doNotCallMount = false) => {\n    let domNode = findComponentRoot(component, refName);\n\n    if (bus) {\n      controller.bus = bus;\n    } else if (domNode) {\n      domNode.$ringaControllers = domNode.$ringaControllers || [];\n      domNode.$ringaControllers.push(controller);\n\n      controller.bus = domNode;\n    } else {\n      console.warn(`attach(): could not find domNode to set as bus for controller ${controller}`);\n    }\n\n    if (_componentDidMount && !doNotCallMount) {\n      _componentDidMount();\n    }\n\n    if (callback) {\n      callback();\n    }\n  };\n\n  component.componentDidMount = postMountFunction;\n\n  if (component.mounted) {\n    postMountFunction(true);\n  }\n\n  component.componentWillUnmount = () => {\n    let domNode = findComponentRoot(component, refName);\n    let ix;\n\n    if (domNode && domNode.$ringaControllers) {\n      ix = domNode.$ringaControllers.indexOf(controller);\n\n      domNode.$ringaControllers.splice(ix, 1);\n    }\n\n    ix = component.$ringaControllers.indexOf(controller);\n    component.$ringaControllers.splice(ix, 1);\n\n    if (_componentWillUnmount) {\n      _componentWillUnmount();\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/attach.js","import {queueState, unqueueState} from './queueState';\nimport {getAllListeningControllers} from './util';\n\n/**\n * Builds a dependency object for use with the depend function.\n *\n * @param classOrId A Class that extends Ringa.Model or a string id of a model you are looking for.\n * @param propertyPath A dot-delimited path into a property on the model. Or undefined if you want the model itself.\n * @param setOnState When true (default), the property will be set on the state of the component, forcing an update.\n *\n * @returns {{classOrId: *, propertyPath: *, setOnState: boolean}}\n */\nexport function dependency(classOrId, propertyPaths = undefined, {setOnState = true, setStateAs = undefined, setOnComponent = false} = {setOnState: true, setOnComponent: false, setStateAs: undefined}) {\n  return {\n    classOrId,\n    propertyPaths,\n    setOnState,\n    setOnComponent,\n    setStateAs\n  };\n}\n\n/**\n * Finds a Ringa.Model or a specific property, given the context of the provided React Component.\n *\n * @param reactComponent A React Component instance.\n * @param classOrId A Class that extends Ringa.Model or a string id of a model you are looking for.\n * @param propertyPath A dot-delimited path into a property on the model. Or undefined if you want the model itself.\n * @returns {*}\n */\nexport function find(reactComponent, classOrId, propertyPath = undefined) {\n  let controllers = getAllListeningControllers(reactComponent);\n  let value;\n\n  for (let i = 0; i < controllers.length; i++) {\n    let controller = controllers[i];\n    let mw = controller.modelWatcher;\n\n    if (mw) {\n      let value = mw.find(classOrId, propertyPath);\n\n      if (value) {\n        return value;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Listens for changes on the provided React Component anywhere in its ancestor tree of Controllers for the requested Ringa.Model and,\n * if desired specific property path, changes. See getAllListeningControllers for information on the controllers and their models\n * that this will depend upon.\n *\n * Example:\n *\n * import {depend, dependency} from 'react-ringa';\n *\n * class MyComponent extends React.Component {\n *   constructor() {\n *     super();\n *\n *     depend(this, dependency('myModelId', 'some.property'));\n *   }\n * }\n *\n * @param component A React Component instance.\n * @param watches An individual or Array of dependency objects. See\n * @param handler A function to callback immediately with all the dependencies that are found right now.\n *\n * @returns {Array}\n */\nexport function depend(component, watches, handler = undefined, debug = false) {\n  let _componentWillMount, _componentWillUnmount, _componentDidMount;\n\n  if (component.componentWillMount) {\n    _componentWillMount = component.componentWillMount.bind(component);\n  }\n\n  if (component.componentWillUnmount) {\n    _componentWillUnmount = component.componentWillUnmount.bind(component);\n  }\n\n  if (component.state === undefined) {\n    component.state = {};\n  }\n\n  let controllers;\n  let mws = [];\n\n  component.componentWillUnmount = () => {\n    unqueueState(component);\n\n    /**\n     * When the component unmounts we want to unwatch everything.\n     */\n    mws.forEach(mwGroup => {\n      mwGroup.mw.unwatch(mwGroup.classOrId, mwGroup.propertyPath, mwGroup.changeHandler);\n    });\n\n    if (_componentWillUnmount) {\n      _componentWillUnmount();\n    }\n  };\n\n  component.componentWillMount = () => {\n    let inComponentWillMount = true;\n    controllers = getAllListeningControllers(component);\n\n    if (!controllers.length) {\n      console.error(`react-ringa depend(): could not find any Ringa Controllers in the ancestors of ${component.constructor.name}, the following dependencies will NOT work: `, watches, component);\n\n      return;\n    }\n\n    if (__DEV__ && debug) {\n      console.log(`depend(${component}, ${watches}) found controllers:`, controllers);\n    }\n\n    watches = watches instanceof Array ? watches : [watches];\n\n    watches.forEach(watch => {\n      let foundModels = [];\n\n      controllers.forEach(controller => {\n        let mw = controller.modelWatcher;\n\n        if (mw) {\n          let model = mw.find(watch.classOrId);\n\n          if (!model) {\n            return;\n          }\n\n          foundModels.push(model);\n\n          if (__DEV__ && foundModels.length > 1) {\n            console.warn(`depend(): found two models while looking for a dependency on the '${component.constructor.name}' component! Watch is:\\n`, watch, `\\nFound these conflicting models during the search, all of which match:\\n`, foundModels, `\\ndepend() looks for the closest model in the DOM tree ancestors it can find that matches the watch criteria. This means you might have a problem in your stack. Proceeding normally with the first model in the list above. This might NOT be the right model and could cause errors. This error will not appear in production.`);\n\n            return;\n          }\n\n          // By default the model we are requesting automatically gets set on the state no matter what for\n          // easy access. However, we don't watch the entire model because that would be silliness. Each view\n          // component should request the specific signals it wants to watch.\n          let s = {};\n          s[watch.setStateAs || model.name] = model;\n          queueState(component, s, inComponentWillMount);\n\n          let value, changeHandler;\n\n          // If the user is just asking for the model (no propertyPath), we can skip all the watching jargon.\n          if (watch.propertyPaths) {\n\n            let pp = watch.propertyPaths instanceof Array ? watch.propertyPaths : [watch.propertyPaths];\n\n            // Create Change Handler. Note we do not use an arrow function here to save memory.\n            changeHandler = function (watch, changes) {\n              let skipUpdate = handler ? handler(changes) : undefined;\n\n              if (skipUpdate === undefined && watch.setOnState) {\n                let newState = {};\n\n                changes.forEach(change => {\n                  let state = {};\n\n                  if (change.propertyObj && change.propertyObj.setStateAs) {\n                    /**\n                     * IF dependency(MyModel, 'property', {setStateAs: 'someOtherPropertyName'})\n                     */\n                    state[change.propertyObj.setStateAs] = change.watchedValue;\n                  } else if (change.watchedPath) {\n                    /**\n                     * IF dependency(MyModel, 'property.*')\n                     */\n                    if (change.watchedPath.endsWith('*')) {\n                      /**\n                       * IF dependency(MyModel, 'property.*') AND the signal was directly from MyModel\n                       */\n                      if (change.initial) {\n                        // This only occurs on the initial depend, when no signals have yet been dispatched, so we\n                        // can prepopulate each value.\n                        change.watchedModel.properties.forEach(prop => {\n                          state[prop] = change.watchedModel[prop];\n                        });\n                      } else {\n                        state[change.signalPath.split('.').pop()] = change.signalValue;\n                      }\n                    } else {\n                      /**\n                       * IF dependency(MyModel, 'property')\n                       */\n                      let prop = change.watchedPath.split('.').pop();\n                      state[prop] = change.watchedValue;\n                    }\n                  } else {\n                    /**\n                     * IF dependency(MyModel)\n                     */\n                    state[change.watchedModel.name] = change.watchedValue;\n                  }\n\n                  newState = Object.assign(newState, state);\n                });\n\n                queueState(component, newState, inComponentWillMount);\n              }\n            }.bind(undefined, watch);\n\n            pp.forEach(propertyPath => {\n              let propertyPathObj;\n\n              if (typeof propertyPath === 'object') {\n                propertyPathObj = propertyPath;\n                propertyPath = propertyPathObj.propertyPath;\n              }\n\n              value = mw.find(watch.classOrId, propertyPath);\n\n              mws.push({\n                mw,\n                classOrId: watch.classOrId,\n                propertyPath,\n                propertyPathObj,\n                changeHandler\n              });\n\n              mw.watch(watch.classOrId, propertyPath, changeHandler);\n\n              if (changeHandler) {\n                changeHandler([{\n                  watchedModel: model,\n                  signalValue: value,\n                  watchedPath: propertyPath,\n                  watchedValue: value,\n                  propertyPathObj,\n                  initial: true\n                }]);\n              }\n            });\n          }\n        }\n      });\n\n      if (!foundModels.length) {\n        if (!watch.classOrId) {\n          console.error(`depend(): could not the model as it was not specified!`);\n        } else {\n          console.error(`depend(): could not find the model`, watch.classOrId.name, `in any ancestor Controllers of React component`, component.constructor.name, component, `during the componentDidMount() phase. Found these instantiated and attached controllers`, controllers);\n        }\n      }\n    });\n\n    if (_componentWillMount) {\n      _componentWillMount();\n    }\n\n    inComponentWillMount = false;\n  };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/depend.js","import {queueState, unqueueState} from './queueState';\n\nexport default function watch(reactComponent, model, signals = [], callback = undefined) {\n  if (model) {\n    if (!model.watch) {\n      throw new Error(`react-ringa watch(): the provided object is not a Ringa Model '${model}'`);\n    }\n\n    let _componentWillUnmount = reactComponent.componentWillUnmount ? reactComponent.componentWillUnmount.bind(reactComponent) : undefined;\n\n    reactComponent.$watches = reactComponent.$watches || {};\n\n    let curHandler = reactComponent.$watches[model.id];\n    if (curHandler) {\n      model.unwatch(curHandler);\n    }\n\n    let handler = reactComponent.$watches[model.id] = (signal, item, value, descriptor, path) => {\n      let fu;\n      let found = false;\n      signals.forEach(_signal => {\n        let subSignal = _signal.split('*')[0];\n\n        if (signal.startsWith(subSignal)) {\n          found = true;\n        }\n      });\n\n      if (!found && signals.length) {\n        return;\n      }\n\n      if (callback) {\n        fu = callback.apply(undefined, [signal, item, value, descriptor, path]);\n      }\n\n      if (fu === undefined) {\n        let o = {};\n        o[model.name] = model;\n        queueState(reactComponent, o);\n      }\n    };\n\n    let unwatch = () => {\n      unqueueState(reactComponent);\n\n      model.unwatch(handler);\n    };\n\n    reactComponent.componentWillUnmount = () => {\n      unwatch();\n\n      if (_componentWillUnmount) {\n        _componentWillUnmount();\n      }\n    };\n\n    model.watch(handler);\n\n    // Initial setup\n    let o = {};\n    o[model.name] = model;\n\n    queueState(reactComponent, o);\n\n    return unwatch;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/watch.js","import attach from './attach';\nimport watch from './watch';\n\nimport {depend, dependency, find} from './depend';\nimport {walkReactParents, getAllListeningControllers, domNodeToNearestReactComponent, domNodeToNearestReactComponentDomNode, getAllReactComponentAncestors} from './util';\n\nexport {attach,\n        depend,\n        dependency,\n        walkReactParents,\n        find,\n        getAllListeningControllers,\n        watch,\n        domNodeToNearestReactComponent,\n        getAllReactComponentAncestors,\n        domNodeToNearestReactComponentDomNode};\n\nexport default {\n  attach,\n  depend,\n  dependency,\n  walkReactParents,\n  find,\n  getAllListeningControllers,\n  watch,\n  domNodeToNearestReactComponent,\n  getAllReactComponentAncestors,\n  domNodeToNearestReactComponentDomNode\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","module.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\",\"umd\":\"react\"}\n// module id = 6\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"ReactDOM\",\"commonjs2\":\"react-dom\",\"commonjs\":\"react-dom\",\"amd\":\"react-dom\",\"umd\":\"react-dom\"}\n// module id = 7\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"Ringa\",\"commonjs2\":\"ringa\",\"commonjs\":\"ringa\",\"amd\":\"ringa\",\"umd\":\"ringa\"}\n// module id = 8\n// module chunks = 0"],"sourceRoot":""}